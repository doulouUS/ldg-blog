---
layout: post
title: "“My data scientist doesn’t know how to properly start an EC2 instance”."
canonical_url: https://medium.com/data-science/my-data-scientist-doesnt-know-how-to-properly-start-an-ec2-instance-b1b9f4920359?source=rss-7a9ab51dbc22------2
tag:
- aws
- cloud-services
- technology
- data-science
- cloud-computing
---

<h4><em>VPC, subnets or Internet Gateways refer to components that are at the heart of any AWS setup. However, data scientists often assume that it will be configured for them. Let’s introduce the most important concepts and gain a clear understanding of their roles.</em></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*azvue-vaBYDDjBDVe2-w0Q.jpeg" /><figcaption>Singapore’s CBD using Neural Style Transfer, using this <a href="https://github.com/ProGamerGov/neural-style-pt">Code</a> and <a href="https://arxiv.org/abs/1508.06576">Paper</a>.</figcaption></figure><p><a href="https://medium.com/@louisdge/catching-up-with-the-cloud-trend-and-the-aws-ecosystem-dd512e8e2456">In my previous post</a>, we set up a cloud infrastructure for a resilient and data-intensive app, at a high level as shown below. I recommend going through this post if you don’t have a good understanding of AWS regions, AZs or High Availability zones.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*F-KO2_NhVED2glCslRfjCw.png" /><figcaption>Example of a cloud architecture from our previous post</figcaption></figure><p>Let’s use this example to explain the underlying Networking and Security concepts. Feel free to go to the AWS console and start the resources (most are free to start) as we present them. After reading this article, you’ll be able to understand what you are actually doing when setting up an EC2 instance. More than that, it will also enable you to configure other AWS services and link them together. Also, parts are reasonably independent so feel free to jump straight to the concepts as the need arises.</p><p><strong>I. Isolating your infrastructure</strong></p><ol><li><em>VPC</em></li><li><em>Subnet</em></li></ol><p><strong>II. Communicating between your instances and networks</strong></p><ol><li><em>Elastic Network Interfaces</em></li><li><em>Internet Gateway</em></li><li><em>Route table</em></li></ol><p><strong>III. Security matters</strong></p><ol><li><em>Security groups</em></li><li><em>NACLs</em></li></ol><p>Let’s get started!</p><h3>Isolating your infrastructure</h3><p>First, remember that the Internet is fundamentally a huge network where nodes are made of servers or computers like yours, identified by a public <a href="https://en.wikipedia.org/wiki/IP_address">Internet Protocol address</a> or <em>IP</em> (like 104.16.122.127). These nodes communicate between themselves using the <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">Internet Protocol Suite</a> (<em>TCP/IP</em>).</p><p>Make sure to familiarize yourself a bit with these concepts before continuing.</p><p>When creating an app in the cloud such as the one presented above, we have exclusive access to a network residing inside a larger public network, created by the cloud provider. This is called a <em>Virtual Private Cloud</em> (VPC) and is the first thing to set up. This is the network inside which all our AWS resources will be running.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*H-I9YeopmIiPi4_1KiO9EQ.png" /><figcaption>Inside the huge network that is the Internet, you get your own private network through a cloud provider.</figcaption></figure><h4>VPC</h4><p>Initially and by default, a VPC is isolated from any other network. It must reside in one AWS region. Then, you need to select some IP addresses that will be used to identify your instances running inside the VPC. This must be done when you start building your infrastructure. For instance, using the <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a> (<em>CIDR</em>) notation, you could set aside these IP addresses (or CIDR <em>block</em>) for your future use: 176.13.0.0/16. This syntax designates all the IP addresses from 176.13.0.0 to 176.13.255.255.</p><p>To make sure you do not overlap these addresses with public IP addresses currently in use on the Internet (like the one of <em>medium.com </em>for instance), you should choose them from the <a href="https://en.wikipedia.org/wiki/Private_network">RFC1918 range</a>. There shouldn’t be an overlap with an existing VPC as well if you intend to connect the two! Choosing your IP addresses range is important as you won’t be able to modify it once your VPC is created. So think about it carefully!</p><p>Note that we’ve used IPv4 addresses in our examples, similar concepts exist for the newer (1998…) IPv6 addresses.</p><h4>Subnet</h4><p>It is not yet time to start our EC2 instances in the VPC we’ve just created: we need another layer. Each instance must be associated with a <em>subnet</em>, which is simply a logical subnetwork inside a VPC. It is defined using a CIDR block, which has to be a subset of the VPC’s CIDR block. For instance, we could define a subnet in the previously created VPC using this CIDR block: 176.13.0.0/24. It is indeed a subset of 176.13.0.0/16.</p><p>Why do we need such subnetworks? There are three main reasons a cloud architect keeps in mind when building an app:</p><ul><li><strong>Isolating instances from each other</strong>: one <em>public</em> subnet could be used for webservers communicating directly with the Internet, while a <em>private </em>subnet could be used to communicate only with webservers.</li><li><strong>Controlling traffic flows between instances: </strong>it is easier to monitor your network and prevent attacks when you have a segmented architecture. It can also boost performance by allowing traffic to only reach some subnets.</li><li><strong>Keeping things organized </strong>by assigning specific functions for each subnet: one subnet could be dedicated to storage for instance with services like RDS.</li></ul><p>Last but not least, you should remember that each subnet can only span one <em>Availability Zone </em>(AZ). As we’ve seen in the previous post, that means resources inside a single subnet are vulnerable to a local failure (as an AZ corresponds to a physical data center). To make your application <em>Highly Available (HA)</em>, you then need to replicate subnets across Availability Zones but still inside the same VPC.</p><p>So let’s see below what it could look like in the app we previously designed.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_YS4h8LXhe6Y7aB-H7YvXw.png" /><figcaption>Basic setup with a single VPC covering one IPv4 block and one IPv6 block, with two subnets spanning two AZs.</figcaption></figure><p>We have now a proper setup for our network. Now, how do we make our instances communicate with each other?</p><h3>Communication between your instances and networks</h3><h4>Elastic Network Interfaces</h4><p>Elastic Network Interface (ENI) is what enables the communication between instances of a network to happen. It is therefore mandatory for any instance to have at least one: it is the link between your instance and one subnet. IP addresses are actually bound to ENI, not instances!</p><p>Most of the time, we omit these ENI because they link a single instance to a single subnet. So our previous architecture should actually look like this (viewing only one AZ for simplicity):</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OnT-soP5RSTr0VLqZqWjpQ.png" /><figcaption>IPs are bound to ENIs, which in turn enable communication with instances.</figcaption></figure><p>ENIs are nonetheless useful to redirect traffic when an instance fails. Consider the case below with two instances:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/834/1*cylBDF09tIQYWhe5VxA5kg.png" /><figcaption>In the case of instance failure, the same IP address can be used while a different instance is used to do the processing job.</figcaption></figure><p>If instance 1 fails, its ENI can be attached to instance 2 as a <em>secondary</em> ENI. From the outside, the traffic still reaches the same IP address, but it is actually processed by another instance behind the hood.</p><p>So now we can communicate inside our subnets, how about communicating with the Internet?</p><h4>Internet Gateway</h4><p>For this, we use an Internet Gateway (IG) as a middle man, attached to a subnet. It will give an instance:</p><ul><li>a <strong>public IP address, </strong>different from the private IP address identifying our instance inside the subnet (so instances can have two IPs — public and private!),</li><li>a <strong>connection to the Internet </strong>to query web clients, for instance,</li><li>the ability to <strong>receive requests </strong>from the Internet</li></ul><p>An IG is associated with a single VPC. You recognize it thanks to its ID on AWS starting with igw-xxx .</p><p>Now, note that we’ve never mentioned how exactly traffic should be flowing between instances, between subnets, between instances and the Internet, etc. That’s where the <em>route table</em> intervenes. It will specify routes from your instances to other instances and to the outside world.</p><h4>Route Tables</h4><p>The first thing you should keep in mind about route tables is that they are linked to one or more subnets. Route tables describe how traffic from the instances of the subnet(s) should be redirected. By route, we mean the following two things:</p><ul><li>A <strong>destination </strong>expressed as an IP address in CIDR notation</li><li>A <strong>target </strong>which is an AWS network resource like an IG, ENI, local or a NAT device (read on to know what is this ;)</li></ul><p>At first, it seemed confusing to me that a route is made of only a destination. It is actually because the origin is the whole subnet associated with the route table.</p><p>Equally confusing: what is the difference between a destination and a target? The destination is the final IP of where you want your packet (data) to end up, while the target is where the packet should go next in order to get closer to this final destination.</p><p>There are in particular two routes that are important and that you will see almost all the time:</p><ul><li>The <em>local route</em> allows instances from one subnet to communicate with other instances of a different subnet, inside your VPC.</li><li>The <em>default route</em> pointing to the Internet Gateway, giving Internet access to the subnet associated with the route table.</li></ul><p>In our app, we could typically configure the following table for our first subnet:</p><pre>----- Example of a Route table for a webserver ----<br>+-------------------------+------------------------+<br>|     Destination         |         Target         |<br>+-------------------------+------------------------+<br>| 2001:db8:1234:1a00::/56 |  local                 |<br>| 0.0.0.0/0               |  igw-0e533011g0frrd318 |<br>| ::/0                    |  igw-0e533011g0frrd318 |<br>+-------------------------+------------------------+</pre><p>You can see that the first route redirects traffic from the first subnet we created to the second one, defined by 2001:db8:1234:1a00::/56. The last two lines simply create an Internet connection with our first subnet by allowing all addresses (“<strong><em>0.0.0.0/0</em></strong><em>”</em> in IPv4 and “<strong><em>::/0</em></strong><em>”</em> in IPv6 refer to all addresses — public and those inside your VPC) to be reached through the IG. The subnet becomes a <em>public subnet </em>thanks to these two lines. Without these connections to the Internet Gateway, it would be a <em>private subnet</em>.</p><p>Let’s update our app’s cloud architecture with these new elements:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pSbgz33J2fkLqN6z1wqbhg.png" /></figure><p>You can see that the upper subnet is public while the one containing the databases is private. Note that the private subnet can still access indirectly the Internet through the public subnet.</p><p>What if now you want to control the traffic going to your instances in a detailed manner? Like which protocol is allowed to reach your instances, on what port, etc.?</p><h3>Security matters</h3><p>Fine-grained control of what is reaching your infrastructure is achieved mainly through the use of <em>Security groups</em> at the instance level, and <em>Network Access Control Lists</em> (NACL) at the subnet level.</p><h4>Security groups</h4><p>A Security group is basically a firewall controlling traffic to and from an instance that has been linked to this Security group. It does this by specifying <em>inbound</em> and <em>outbound</em> rules, made of the following:</p><ul><li>the<strong> source </strong>for inbound rules (respectively <strong>destination </strong>for outbound rules) of the packet expressed as a CIDR block or another security group’s ID</li><li>the<strong> </strong><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite"><strong>Protocol</strong></a><strong> </strong>used to transfer packets to and from the instance (such as TCP)</li><li><a href="https://en.wikipedia.org/wiki/Port_(computer_networking)"><strong>Port</strong></a><strong> range</strong>, which specifies through which ports packets are transiting</li></ul><p>Let’s take the example of an EC2 instance that you want to use as a web server. In this case, you would allow every IP address to be a source as you want your users to access your app, right? In this case, the protocol used to establish a connection between an Internet user and the instance would be TCP while the port range is 443, typically used for <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> data transfers. Now, you may also want to take control of your instance from a remote terminal to do some maintenance work. You will do this over <a href="https://en.wikipedia.org/wiki/Secure_Shell">SSH</a>, and from a specific source (at 197.52.101.10 for instance). With this in mind, the inbound rules of your security group look like this:</p><pre>- Example of Security group Inbound rules -<br>+------------------+----------+------------+<br>|      Source      | Protocol | Port range |<br>+------------------+----------+------------+<br>| 0.0.0.0/0        |    TCP   |        443 |<br>| ::/0             |    TCP   |        443 |<br>| 197.52.101.10/32 |    TCP   |        443 |<br>+------------------+----------+------------+</pre><p>Note that by default, all outside communications are denied. You need to specifically <em>whitelist </em>sources that are going to communicate with your instance.</p><p>On the other hand, all addresses are allowed by default when it comes to outbound communications. It means that your default outbound rules look like this:</p><pre>Default Security Group&#39;s Outbound rules <br>+-------------+----------+------------+<br>| Destination | Protocol | Port range |<br>+-------------+----------+------------+<br>| 0.0.0.0/0   |    TCP   |        443 |<br>| ::/0        |    TCP   |        443 |<br>+-------------+----------+------------+</pre><p>Finally, there is an important concept to remember about security groups: it is said to be <em>stateful</em>. This means that if some traffic is allowed in one direction, then it also allows some reply traffic in the opposite direction. This is important when communicating with Internet clients: our instance may try to send a packet to a web server (like a GET request) and expect an answer. Our security group will allow the answer to go through.</p><p>While Security groups control traffic at the instance level, another service is used to more conveniently control traffic between subnets: <em>NACL</em>.</p><h4>NACLs</h4><p><em>Network Access Control Lists </em>are comparable to Security groups in the sense that they control inbound and outbound traffic using rules. However, one NACL is attached to a subnet and controls traffic that may enter or exit the entire subnet. For traffic between instances of a subnet, Security groups are preferred.</p><p>Similarly to a Security group, NACL implements rules characterized by the following elements:</p><ul><li><strong>Rule number</strong>: an integer used to determine the order in which rules are applied. Lower rule numbers are applied first.</li><li><strong>Protocol</strong>: same field as for Security groups</li><li><strong>Port range</strong>: same field as for Security groups</li><li><strong>Source</strong> for inbound rules (or<strong> destination </strong>for outbound rules): same field as for Security groups</li><li><strong>Action</strong>: either <em>ALLOW</em> or <em>DENY </em>communications with<em> </em>the source or destination</li></ul><p>When creating a subnet, a default NACL is attached to it and can be modified further. Its default inbound rules look like this:</p><pre>--------------- Default NACL Outbound rules -----------------<br>+-------------+-----------+------------+-----------+---------+<br>| Rule Number |  Protocol | Port Range |  Source   |  Action |<br>+-------------+-----------+------------+-----------+---------+<br>| 100         | All       | All        | 0.0.0.0/0 | Allow   |<br>| *           | All       | All        | 0.0.0.0/0 | Deny    |<br>+-------------+-----------+------------+-----------+---------+</pre><p>Beware that all inbound traffic is allowed by default which was not the case with Security groups! Note also the last row with an asterisk as a rule number: it is a default rule that cannot be modified or removed. It denies any traffic not explicitly allowed by the previous rules.</p><p>There is one NACLs’ characteristic that can lead to some bugs and is, therefore, worth remembering: NACLs are <em>stateless</em>. This means it won’t automatically return traffic: you need to specify the outbound rule corresponding to the inbound rule that allowed the communication to happen in the first place. Or you could use <a href="https://en.wikipedia.org/wiki/Ephemeral_port">ephemeral ports</a> but that’s another story!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Yxf_gig7a4Lj98M-bSE2_g.png" /><figcaption>NACLs cover entire subnets while Security Groups operate at the instance level (note that DynamoDB does not have a Security Group, it uses IAM roles instead…)</figcaption></figure><h4>Conclusion</h4><p>We went through the fundamental concepts needed to properly start AWS services. We saw how to arrange instances into subnets depending on their utilization. We also enabled communication between instances and communication with the Internet as well (IG, Route Table). Finally, we protected our infrastructure by specifying which traffic should be allowed to reach our instances (Security groups, NACL).</p><h4><em>Next steps</em></h4><p>Bear in mind that this post only scratched the surface of what it takes to understand cloud architectures. As a next step, it would be interesting for you to play around the AWS UI, creating your own free resources (using free-tier services). Then, there are numerous subtleties that you can learn about by reading the documentation or following the new services regularly launched by AWS:</p><ul><li>For instance, you can still assign IP addresses to a VPC using a <em>secondary CIDR block</em> after creating the VPC (as announced <a href="https://aws.amazon.com/about-aws/whats-new/2017/08/amazon-virtual-private-cloud-vpc-now-allows-customers-to-expand-their-existing-vpcs/">here</a>). This is to allow scaling on-the-go when you need more resources.</li><li>It is better to restrict outbound traffic using Security groups as with updates, ports may change and NACLs don’t allow dynamic change to it.</li><li>You can have exclusive access and use of a range of public IP addresses using <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP addresses</a>.</li><li>Simply re-route traffic from a private subnet to a <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html\">NAT device</a> in order to further protect your sensitive instances (databases, etc.)</li><li>and much more…</li></ul><p>As always thanks for reading, and please do not hesitate to provide feedback or comments for me to also improve my understanding of the subject.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b1b9f4920359" width="1" height="1" alt=""><hr><p><a href="https://medium.com/data-science/my-data-scientist-doesnt-know-how-to-properly-start-an-ec2-instance-b1b9f4920359">“My data scientist doesn’t know how to properly start an EC2 instance”.</a> was originally published in <a href="https://medium.com/data-science">TDS Archive</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
